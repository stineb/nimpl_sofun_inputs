---
output:
  word_document: default
  pdf_document: default
  html_document: default
---

---
title: "Global input for all prediction field"
author: "Yunke Peng"
date: "June 24 2020"
output: html_document
---

## Introduction about Global nc files

Elements below are global inputs that will be used in statistical model-based calculations. All data has a final resolution as 0.5 * 0.5 degree - though the resample procedure was needed for soil C/N and LMA. All climate or environmental data (fAPAR, alpha, PPFD, Tg, vpd) has constrained the year from 1982 to 2011 (30 yrs average); while some others (soil C/N, age and LMA) also had a long-term average, according to their paper's description.

 * Soil C/N (ISRIC; previously asssited by Nick Smith and Trevor Keenan in 2019)
 * stand age (yrs) (Poulter et al. 2019: https://doi.pangaea.de/10.1594/PANGAEA.889943)
 * fAPAR (3g GIMMS: https://developers.google.com/earth-engine/datasets/catalog/NASA_GIMMS_3GV0)
 * alpha (SPLASH: asssited by David Sandoval)
 * PPFD (umol/m2/s) (WFDEI: http://www.eu-watch.org/gfx_content/documents/README-WFDEI%20(v2016).pdf)
 * Tg (degree celcius) (CRU ts 4.01: https://crudata.uea.ac.uk/cru/data/hrg/cru_ts_4.01/)
 * vpd (kPa) (CRU ts 4.01: https://crudata.uea.ac.uk/cru/data/hrg/cru_ts_4.01/)
 * LMA (g/m2) (TRY Global traits map 3km: https://isp.uv.es/code/try.html)
 * Vcmax25 (umol/m2/s) (will be further processed in Beni Stocker's SOFUN in Euler).
 
The process below will provide original codes of soil C/N, stand age, fAPAR, alpha and LMA, as well as description text of PPFD, Tg, vpd. Vcmax25 will be seperately processed in SOFUN in Euler then.


#1. soil C/N

```{r}
library(raster)

soil <- raster('~/data/nimpl_sofun_inputs/map/Original_data/soilCN/ISRIC_raster/w001000.adf') # map input from the last 2015 version of ISRIC (Batjes 2015 ISRIC report)

Global_grid <- as.data.frame(read.csv(file="~/data/nimpl_sofun_inputs/map/Original_data/soilCN/Global_cell.csv")) #Input global land grids (0.5 degree;N = 259200)

Global_grid$ID <- c(1:259200) #create a list of number, just helping to form a raster then.

pointXY<-SpatialPointsDataFrame(Global_grid[,c('lon','lat')], data=data.frame(unique.id=paste(Global_grid$ID))) # convert to spatial data format 

vec.soil.extract <-extract(soil,pointXY) 
data.soil.extract <-data.frame(pointXY,SUID=vec.soil.extract) 
# These two steps are important, it will extract SUID information from soil map (.adf) to our grids data, so that each our global grid will have a unique SUID, which will be further combined (merged) with soil C/N data then.

ISRIC.data<-read.csv(file="~/data/nimpl_sofun_inputs/map/Original_data/soilCN/HW30s_FULL.csv",header=TRUE,sep=";",dec = ".") # Now, input ISRIC database

data.soil.extract <- merge(data.soil.extract,ISRIC.data,by='SUID',all.x=TRUE) # merge site with soil variables by using SUID

data.soil.extract2 <- subset(data.soil.extract,CNrt>0) # select available CNrt
data.soil.extract3 <- data.soil.extract2[,c("lon","lat","CNrt")] # only select CNrt variable

ss1 <- aggregate(data.soil.extract3,by=list(data.soil.extract3$lon,data.soil.extract3$lat), FUN=mean, na.rm=TRUE) # note that in each grid there might be more than 1 samples measured, so we should aggregate them which make sures that one grid holds one data only.

ss2 <- ss1[,c(3,4,5)] # now,select lon, lat and CNrt only


final_CN <-Reduce(function(x,y) merge(x = x, y = y, by = c("lon","lat"),all.x=TRUE), 
                   list(Global_grid,ss2)) #merged this with global grids (N = 259200)

#convert dataframe to raster
coordinates(final_CN) <- ~lon+lat 

gridded(final_CN) <- TRUE

rCNrt <- raster(final_CN, "CNrt") 
plot(rCNrt)

```


#2. stand age
```{r}
library(raster)
library(ncdf4)

#set the path and filename
ncfname <- paste ("~/data/nimpl_sofun_inputs/map/Original_data/age/", "GFAD_V1-1", ".nc", sep="")

dname <- "age"

#1. open a netCDF file and check variable
ncin <- nc_open(ncfname)
print(ncin)#here ncin includes 4 pfts at 15 age classes

#2. Get coordinate and value
lon <- ncvar_get(ncin,"lon")
nlon <- dim(lon) 

lat<-ncvar_get(ncin,"lat")
nlat<-dim(lat)

age <-ncvar_get(ncin,"age")

nc_close(ncin)

pre.vec.long <- as.vector(age)

pre.mat <- matrix(pre.vec.long, nrow = nlon * nlat, ncol = 4*15) # 259200 columns * 60 rows - here 60 represents 4 PFTs and 15 age classes.

lonlat <- expand.grid(lon, lat)

#here we calculated age as a sum of 15 age classes in 4 plant functional types.
lonlat$age <- rowSums(pre.mat[,1:4])*5+rowSums(pre.mat[,5:8])*15+rowSums(pre.mat[,9:12])*25+rowSums(pre.mat[,13:16])*35+
  rowSums(pre.mat[,17:20])*45+rowSums(pre.mat[,21:24])*55+rowSums(pre.mat[,25:28])*65+rowSums(pre.mat[,29:32])*75+
  rowSums(pre.mat[,33:36])*85+rowSums(pre.mat[,37:40])*95+rowSums(pre.mat[,41:44])*105+rowSums(pre.mat[,45:48])*115+
  rowSums(pre.mat[,49:52])*125+rowSums(pre.mat[,53:56])*135+rowSums(pre.mat[,57:60])*145


names(lonlat) <- c("lon","lat","age")

age_input <- as.data.frame(lonlat)
coordinates(age_input) <- ~lon+lat 
gridded(age_input) <- TRUE
r <- raster(age_input, "age") 
plot(r)

``` 
#3. fAPAR
```{r}
library(ncdf4)
library(raster)
ncfname <- paste ("~/data/fAPAR/fAPAR3g_v2/", "fAPAR3g_v2_1982_2016_FILLED", ".nc", sep="")
dname <- "FAPAR_FILLED"

ncin <- nc_open(ncfname)
print(ncin) #here nc file includes 420 lists (35 yrs * 12 month)

lon <- ncvar_get(ncin,"LON")
nlon <- dim(lon) 

lat<-ncvar_get(ncin,"LAT")
nlat <- dim(lat)

FAPAR <- ncvar_get(ncin,"FAPAR_FILLED")
nc_close(ncin)

pre.vec.long <- as.vector(FAPAR)

pre.mat <- matrix(pre.vec.long, nrow = nlon * nlat, ncol = 420) # 259200 * 420 (420 is 35 years: 1982-2016)

fAPAR1982_2011 <- pre.mat[,c(1:360)] #extrat fAPAR from 1982-2011

final_fAPAR <- rowMeans(fAPAR1982_2011,na.rm = TRUE)

lonlat <- expand.grid(lon, lat)
fAPAR_input <- as.data.frame(cbind(lonlat,final_fAPAR))
names(fAPAR_input) <- c("lon","lat","fAPAR")

coordinates(fAPAR_input) <- ~lon+lat 
gridded(fAPAR_input) <- TRUE
r3 <- raster(fAPAR_input, "fAPAR") 
plot(r3)
```
#4. alpha

```{r}
library(raster)
alphalist <- list.files(path = "~/data/nimpl_sofun_inputs/map/Original_data/alpha/",full.names = T) # here this file includes 116 data - that is the annual alpha from 1901 to 2016

empty_alpha <- data.frame(matrix(NA)) 

#calculate alpha within 30 years (1982-2011)
for (i in 82:111){ #here 82:111 means 1982-2011
  load(file = alphalist[i])
  empty_alpha[1:259200,i-81] <- rowMeans(SP_result_monthly,na.rm = TRUE)
}

final_alpha <- rowMeans(empty_alpha,na.rm = TRUE)

alpha_input <- as.data.frame(cbind(lonlat,final_alpha)) 
names(alpha_input) <- c("lon","lat","alpha")

coordinates(alpha_input) <- ~lon+lat 
gridded(alpha_input) <- TRUE

r4 <- raster(alpha_input, "alpha") 
plot(r4)
``` 

#5. PPFD (description and main calculation were provided)
PPFD is instantaneous photosynthetic photon flux density (umol/m2/s). We used the 30 yrs average data (1982-2011), which was originally derived from time-integrated (24 hrs) daily Shortwave radiation (SWdown) from WFDEI. In order to convert from SWdown to PPFD, we need to calculate them as:

PPFD (umol/m2/s) = SWdown (w/m2) * 4.6 * 0.5 

where Solar radiation was converted to incident PPFD assuming a flux : energy ratio of 4.6 umol/J and a photosynthetically active fraction of 0.50 (Peng et al. 2020; New Phytologist).

The code below will represent the global map of final output:

```{r}
library(raster)
library(ncdf4)

ncfname <- paste ("~/data/nimpl_sofun_inputs/map/Original_data/PPFD/", "PPFD", ".nc", sep="")
dname <- "PPFD"
ncin <- nc_open(ncfname)

lon <- ncvar_get(ncin,"lon")
nlon <- dim(lon) 
lat<-ncvar_get(ncin,"lat")
nlat <- dim(lat)
PPFD <- ncvar_get(ncin,"PPFD")

nc_close(ncin)

pre.vec.long <- as.vector(PPFD)
lonlat <- expand.grid(lon, lat)
PPFD_input <- as.data.frame(cbind(lonlat,pre.vec.long))
names(PPFD_input) <- c("lon","lat","PPFD")

coordinates(PPFD_input) <- ~lon+lat 
gridded(PPFD_input) <- TRUE
rPPFD <- raster(PPFD_input, "PPFD") 
plot(rPPFD)

``` 

#6. Tg (description and main calculation were provided)
Tg is growth temperature (degree celcius). We used the 30 yrs average data (1982-2011), which was originally derived from monthly maximum temperature (Tmx) and minimum temperature (Tmn) from CRU ts 4.01. See formula below:

Tg_cal <- function(tmn,tmx){
  #-----------------------------------------------------------------------
  # Input:   sai (s; solar delclination), 12 month constant values
  # Input:   tmn, in monthly or daily degrees
  # Input:   tmx, in monthly or daily degrees
  # Input:   lat, in degrees
  # Output:  Tg,  in monthly or daily degrees
  # Features: Converts growth temperature from tmn, tmx, lon
  #-----------------------------------------------------------------------
  s1 <- -20.205
  s2 <- -12.65
  s3 <- -1.95
  s4 <- 9.45
  s5 <- 18.35
  s6 <- 22.55
  s7 <- 20.75
  s8 <- 13.45
  s9 <- 2.9
  s10 <- -8.45
  s11 <- -17.85
  s12 <- -22.355
  s <- c(s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12)
  x <-data.frame(matrix(nrow = 259200,ncol=12)) ##create x dataframe: nrow=No. of sites, ncol=monthly step
  Tg <-data.frame(matrix(nrow = 259200,ncol=12))##see above
  
  for (i in 1:12){
  x[,i]<- -tan(pi*lat/180)*tan(s[i]*pi/180)
  Tg[,i]<-tmx[,i]*(0.5+(1-x[,i]^2)^(0.5)/(2*acos(x[,i])))+ tmn[,i]*(0.5-(1-x[,i]^2)^(0.5)/(2*acos(x[,i])))
    }
  Tg[Tg<0] <-NA
  Tg[Tg =="NaN"] <- NA
  return(Tg)
}

where Tg was calculated from Tmn and Tmx based on monthly average data (Peng et al. 2020 submitted to GCB).The code below will represent the global map of final output:

```{r}
library(raster)
library(ncdf4)

ncfname <- paste ("~/data/nimpl_sofun_inputs/map/Original_data/Tg/", "Tg", ".nc", sep="")
dname <- "Tg"

ncin <- nc_open(ncfname)

lon <- ncvar_get(ncin,"lon")
nlon <- dim(lon) 
lat<-ncvar_get(ncin,"lat")
nlat <- dim(lat)

Tg <- ncvar_get(ncin,"Tg")
nc_close(ncin)

pre.vec.long <- as.vector(Tg)
lonlat <- expand.grid(lon, lat)
Tg_input <- as.data.frame(cbind(lonlat,pre.vec.long))
names(Tg_input) <- c("lon","lat","Tg")

coordinates(Tg_input) <- ~lon+lat 
gridded(Tg_input) <- TRUE
rTg <- raster(Tg_input, "Tg") 
plot(rTg)
``` 


#7. vpd (description and main calculation were provided)
vpd is vapor-pressure-deficient (kPa). We used the 30 yrs average data (1982-2011), which was originally derived from monthly data from CRU ts 4.01. See formula below (Peng et al. 2020 New Phytologist):

vpd <- 0.611*exp(17.27*(Tg)/((Tg)+237.3))-vap*0.1 
where Tg (in celcius degree) was derived from above, and vap (hPa) was derived from CRU ts 4.01 monthly data. The code below shows the global map of final output.
```{r}
library(raster)
library(ncdf4)
ncfname <- paste ("~/data/nimpl_sofun_inputs/map/Original_data/vpd/", "vpd", ".nc", sep="")
dname <- "vpd"

ncin <- nc_open(ncfname)

lon <- ncvar_get(ncin,"lon")
nlon <- dim(lon) 
lat<-ncvar_get(ncin,"lat")
nlat <- dim(lat)
vpd <- ncvar_get(ncin,"vpd")

nc_close(ncin)

pre.vec.long <- as.vector(vpd)
lonlat <- expand.grid(lon, lat)
vpd_input <- as.data.frame(cbind(lonlat,pre.vec.long))
names(vpd_input) <- c("lon","lat","vpd")

coordinates(vpd_input) <- ~lon+lat 
gridded(vpd_input) <- TRUE
rvpd <- raster(vpd_input, "vpd") 
plot(rvpd)
``` 
#8. LMA (a resample method was pre-processed in advance, see text below)
Here the SLA tiff. file was originally downloaded from TRY (see link on above). Then I have inputted this tiff file into ArcGIS, and then interpolating all global grids points (N = 259200) from the tiff map, using "Extract multi values to points" function. This will enable us to output a global grid dataframe (in csv), that includes LMA values from 720*360 grids.

```{r}
library(raster)
library(ncdf4)

SLA_extracted <- read.csv(file="~/data/nimpl_sofun_inputs/map/Original_data/LMA/SLA_export.csv") #This dataframe outputted from ArcGIS, including FID, lon, lat, Elevation, SLA (mg/mm)
SLA_extracted2 <- subset(SLA_extracted,SLA_3km_v1>0) #remove NA or negative values

SLA_extracted2$LMA <- 1000/SLA_extracted2$SLA_3km_v1 #mg/mm -> g/m2

SLA_extracted3 <- SLA_extracted2[,c(2,3,6)] #only select lon, lat and LMA (g/m2)

names(lonlat) <- c("lon","lat") #here lonlat was derived from previous coordinates data, which can be continuously used

final_lma <-Reduce(function(x,y) merge(x = x, y = y, by = c("lon","lat"),all.x=TRUE), 
                        list(lonlat,SLA_extracted3)) #combined with global grids

coordinates(final_lma) <- ~lon+lat 
gridded(final_lma) <- TRUE
rLMA <- raster(final_lma, "LMA") 
plot(rLMA)

``` 


#NC files generation
After finishing map at each vairable, we can directly outputing such object (e.g. rLMA above) to nc file, using WriteRaster function in r. An example code outputnig rLMA is on below:

d <- writeRaster(rLMA, paste0("E:/R code/CN MS/PhD/NC files/","LMA.nc"),
                 format = "CDF", overwrite = TRUE, varname = "LMA", 
                 varunit = "g/m2", longname = "Leaf-mass-per-area (TRY gloabl traits map)", 
                 xname = "lon", yname = "lat")